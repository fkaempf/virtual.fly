import sys
import ctypes

import numpy as np
import pygame
from pygame.locals import DOUBLEBUF, OPENGL, QUIT, KEYDOWN, K_ESCAPE
from OpenGL import GL

# -------------------------------------------------------------
# CONFIG: paths and mapping -> warp texture
# -------------------------------------------------------------

MAPX_PATH = r"D:/screen.calibration/configs/camera.projector.mapping/mapx.experimental.npy"
MAPY_PATH = r"D:/screen.calibration/configs/camera.projector.mapping/mapy.experimental.npy"

mapx = np.load(MAPX_PATH).astype(np.float32)  # shape (H, W)
mapy = np.load(MAPY_PATH).astype(np.float32)
PROJ_H, PROJ_W = mapx.shape

valid = np.isfinite(mapx) & np.isfinite(mapy) & (mapx >= 0) & (mapy >= 0)
if not np.any(valid):
    raise RuntimeError("mapx/mapy contain no valid entries")

cam_w = int(np.ceil(mapx[valid].max())) + 1
cam_h = int(np.ceil(mapy[valid].max())) + 1

warp = np.zeros((PROJ_H, PROJ_W, 2), dtype=np.float32)
warp[..., 0] = mapx / float(cam_w)  # u
warp[..., 1] = mapy / float(cam_h)  # v
warp[~valid, 0] = -1.0
warp[~valid, 1] = -1.0


# -------------------------------------------------------------
# SHADERS
# -------------------------------------------------------------

VERT_SRC = r"""
#version 330 core

in vec2 in_pos;   // clip-space position (-1..1)
in vec2 in_uv;    // projector uv (0..1)
out vec2 v_uv;

void main() {
    gl_Position = vec4(in_pos, 0.0, 1.0);
    v_uv = in_uv;
}
"""

FRAG_SRC = r"""
#version 330 core

in vec2 v_uv;
out vec4 fragColor;

uniform sampler2D u_cam;   // camera image
uniform sampler2D u_warp;  // warp map (RG = camera UV)

void main() {
    vec2 cam_uv = texture(u_warp, v_uv).rg;

    // invalid mapping marker: u < 0
    if (cam_uv.x < 0.0 || cam_uv.y < 0.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }

    vec3 col = texture(u_cam, cam_uv).rgb;
    fragColor = vec4(col, 1.0);
}
"""


# -------------------------------------------------------------
# GL HELPERS
# -------------------------------------------------------------

def compile_shader(source, shader_type):
    shader = GL.glCreateShader(shader_type)
    GL.glShaderSource(shader, source)
    GL.glCompileShader(shader)
    status = GL.glGetShaderiv(shader, GL.GL_COMPILE_STATUS)
    if not status:
        log = GL.glGetShaderInfoLog(shader).decode()
        raise RuntimeError(f"Shader compile error ({shader_type}):\n{log}")
    return shader


def create_program(vs_src, fs_src):
    vs = compile_shader(vs_src, GL.GL_VERTEX_SHADER)
    fs = compile_shader(fs_src, GL.GL_FRAGMENT_SHADER)
    prog = GL.glCreateProgram()
    GL.glAttachShader(prog, vs)
    GL.glAttachShader(prog, fs)
    GL.glLinkProgram(prog)
    status = GL.glGetProgramiv(prog, GL.GL_LINK_STATUS)
    if not status:
        log = GL.glGetProgramInfoLog(prog).decode()
        raise RuntimeError(f"Program link error:\n{log}")
    GL.glDeleteShader(vs)
    GL.glDeleteShader(fs)
    return prog


def create_texture_2d(width, height, internal_format, fmt, dtype,
                      min_filter=GL.GL_LINEAR, mag_filter=GL.GL_LINEAR):
    tex = GL.glGenTextures(1)
    GL.glBindTexture(GL.GL_TEXTURE_2D, tex)
    GL.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, min_filter)
    GL.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, mag_filter)
    GL.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE)
    GL.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE)

    # allocate storage only; data uploaded later via glTexSubImage2D
    GL.glTexImage2D(
        GL.GL_TEXTURE_2D,
        0,
        internal_format,
        width,
        height,
        0,
        fmt,
        dtype,
        None
    )

    GL.glBindTexture(GL.GL_TEXTURE_2D, 0)
    return tex


# -------------------------------------------------------------
# MAIN
# -------------------------------------------------------------

def main():
    # 1) Init pygame + GL context
    pygame.init()
    pygame.display.set_mode((PROJ_W, PROJ_H), DOUBLEBUF | OPENGL)
    pygame.display.set_caption("GPU warp demo")

    GL.glViewport(0, 0, PROJ_W, PROJ_H)
    GL.glDisable(GL.GL_DEPTH_TEST)

    # 2) Compile shaders and link program
    prog = create_program(VERT_SRC, FRAG_SRC)
    GL.glUseProgram(prog)

    # 3) Full-screen quad geometry (positions + UVs)
    quad_vertices = np.array([
        # x,    y,    u,   v
        -1.0, -1.0, 0.0, 0.0,
         1.0, -1.0, 1.0, 0.0,
        -1.0,  1.0, 0.0, 1.0,
         1.0,  1.0, 1.0, 1.0,
    ], dtype=np.float32)

    vao = GL.glGenVertexArrays(1)
    vbo = GL.glGenBuffers(1)

    GL.glBindVertexArray(vao)
    GL.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo)
    GL.glBufferData(GL.GL_ARRAY_BUFFER, quad_vertices.nbytes, quad_vertices, GL.GL_STATIC_DRAW)

    stride = 4 * quad_vertices.itemsize  # 4 floats per vertex

    loc_pos = GL.glGetAttribLocation(prog, "in_pos")
    loc_uv = GL.glGetAttribLocation(prog, "in_uv")

    GL.glEnableVertexAttribArray(loc_pos)
    GL.glVertexAttribPointer(
        loc_pos,
        2,
        GL.GL_FLOAT,
        GL.GL_FALSE,
        stride,
        ctypes.c_void_p(0)
    )

    GL.glEnableVertexAttribArray(loc_uv)
    GL.glVertexAttribPointer(
        loc_uv,
        2,
        GL.GL_FLOAT,
        GL.GL_FALSE,
        stride,
        ctypes.c_void_p(2 * quad_vertices.itemsize)
    )

    GL.glBindBuffer(GL.GL_ARRAY_BUFFER, 0)
    GL.glBindVertexArray(0)

    # 4) Create camera texture and warp texture

    cam_tex = create_texture_2d(
        cam_w,
        cam_h,
        GL.GL_RGB8,
        GL.GL_RGB,
        GL.GL_UNSIGNED_BYTE,
        min_filter=GL.GL_LINEAR,
        mag_filter=GL.GL_LINEAR,
    )

    warp_tex = create_texture_2d(
        PROJ_W,
        PROJ_H,
        GL.GL_RG32F,
        GL.GL_RG,
        GL.GL_FLOAT,
        min_filter=GL.GL_NEAREST,
        mag_filter=GL.GL_NEAREST,
    )

    # 5) Set samplers to texture units
    u_cam_loc = GL.glGetUniformLocation(prog, "u_cam")
    u_warp_loc = GL.glGetUniformLocation(prog, "u_warp")
    GL.glUseProgram(prog)
    GL.glUniform1i(u_cam_loc, 0)   # cam -> texture unit 0
    GL.glUniform1i(u_warp_loc, 1)  # warp -> texture unit 1

    # 6) Build a test camera image (cam_h x cam_w) - gradient + grid
    yy, xx = np.indices((cam_h, cam_w))
    cam_img = np.zeros((cam_h, cam_w, 3), dtype=np.uint8)
    cam_img[..., 0] = (xx / cam_w * 255).astype(np.uint8)  # red gradient
    cam_img[..., 1] = (yy / cam_h * 255).astype(np.uint8)  # green gradient
    cam_img[..., 2] = 128                                  # blue constant

    cam_img[yy % 50 == 0] = (255, 255, 255)
    cam_img[xx % 50 == 0] = (255, 255, 255)

    cam_img = np.ascontiguousarray(cam_img, dtype=np.uint8)

    # 7) Upload warp texture once
    warp_c = np.ascontiguousarray(warp.astype(np.float32))
    GL.glActiveTexture(GL.GL_TEXTURE1)
    GL.glBindTexture(GL.GL_TEXTURE_2D, warp_tex)
    warp_ptr = warp_c.ctypes.data_as(ctypes.c_void_p)
    GL.glTexSubImage2D(
        GL.GL_TEXTURE_2D,
        0,
        0,
        0,
        PROJ_W,
        PROJ_H,
        GL.GL_RG,
        GL.GL_FLOAT,
        warp_ptr,
    )

    # 8) Initial upload of camera image
    GL.glActiveTexture(GL.GL_TEXTURE0)
    GL.glBindTexture(GL.GL_TEXTURE_2D, cam_tex)
    cam_ptr = cam_img.ctypes.data_as(ctypes.c_void_p)
    GL.glTexSubImage2D(
        GL.GL_TEXTURE_2D,
        0,
        0,
        0,
        cam_w,
        cam_h,
        GL.GL_RGB,
        GL.GL_UNSIGNED_BYTE,
        cam_ptr,
    )

    # 9) Main loop
    running = True
    clock = pygame.time.Clock()

    while running:
        for event in pygame.event.get():
            if event.type == QUIT:
                running = False
            if event.type == KEYDOWN and event.key == K_ESCAPE:
                running = False

        # simple animation in camera texture (horizontal shift)
        t = pygame.time.get_ticks() / 1000.0
        shift = int((np.sin(t) * 0.5 + 0.5) * 50)  # 0..50 px
        shifted = np.roll(cam_img, shift, axis=1)
        shifted = np.ascontiguousarray(shifted, dtype=np.uint8)

        GL.glActiveTexture(GL.GL_TEXTURE0)
        GL.glBindTexture(GL.GL_TEXTURE_2D, cam_tex)
        shift_ptr = shifted.ctypes.data_as(ctypes.c_void_p)
        GL.glTexSubImage2D(
            GL.GL_TEXTURE_2D,
            0,
            0,
            0,
            cam_w,
            cam_h,
            GL.GL_RGB,
            GL.GL_UNSIGNED_BYTE,
            shift_ptr,
        )

        GL.glViewport(0, 0, PROJ_W, PROJ_H)
        GL.glClearColor(0.0, 0.0, 0.0, 1.0)
        GL.glClear(GL.GL_COLOR_BUFFER_BIT)

        GL.glUseProgram(prog)
        GL.glBindVertexArray(vao)

        GL.glActiveTexture(GL.GL_TEXTURE0)
        GL.glBindTexture(GL.GL_TEXTURE_2D, cam_tex)
        GL.glActiveTexture(GL.GL_TEXTURE1)
        GL.glBindTexture(GL.GL_TEXTURE_2D, warp_tex)

        GL.glDrawArrays(GL.GL_TRIANGLE_STRIP, 0, 4)

        GL.glBindVertexArray(0)

        pygame.display.flip()
        clock.tick(60)

    # Cleanup
    GL.glDeleteTextures([cam_tex, warp_tex])
    GL.glDeleteBuffers(1, [vbo])
    GL.glDeleteVertexArrays(1, [vao])
    GL.glDeleteProgram(prog)
    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()

